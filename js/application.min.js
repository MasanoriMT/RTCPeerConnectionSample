document.addEventListener('DOMContentLoaded', function() {
    var socketURL  = 'ws://localhost:8124';
    var doc        = document;
    var remote     = doc.getElementById('remoteVideo');
    var local      = doc.getElementById('localVideo');
    var members    = doc.getElementById('members');
    var server     = [{"url": "stun:stun.l.google.com:19302"}];
    var peer       = null;
    var memberList = null;
    var chat       = null;
    var websokcet  = null;
    var accessName = "";
    var uuid       = "";
    var RTCPeerConnection = window.mozRTCPeerConnection || window.webkitRTCPeerConnection || window.RTCPeerConnection;
    var RTCIceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
    var RTCSessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription;
    navigator.getUserMedia = navigator.getUserMedia || navigator.mozGetUserMedia || navigator.webkitGetUserMedia;

// Observer Interface
var Observer   = {};
Observer.onAddStream = function(evt) {
    console.log('Stream attached');
    remote.src = window.URL.createObjectURL(evt.stream);
};

Observer.onRemoveStream = function(evt) {
    remote.src = '';
};
Observer.onNegotiationNeeded = function(evt) {
    console.log('Negotiation event');
    //this.peer.createOffer(this.onLocalDescrion, this.errorHandler);
};
Observer.onIceCandidate = function(evt) {
    if ( ! evt.candidate ) {
        return;
    }
    websocket.send(JSON.stringify({
        "candidate": evt.candidate,
        "type":      PeerConnection.MESSAGE_TYPE_CANDIDATE
    }));
};
Observer.onWebSocketMessage = function(evt) {
    var message = JSON.parse(evt.data),
        sessionDescription,
        candidate;

    switch ( message.type ) {
        case PeerConnection.MESSAGE_TYPE_SDP:
            sessionDescription = new RTCSessionDescription(message.sdp);
            if ( message.to && message.to === uuid ) {
                switch ( sessionDescription.type ) {
                    case PeerConnection.DESCRIPTION_TYPE_OFFER:
                        console.log('Remote description set');
                        console.dir(sessionDescription);
                        if ( confirm('接続名：' + message.accessName + 'からCallが届いています。応答しますか？') ) {
                            this.peer.setRemoteDescription(sessionDescription, function() {
                                this.createAnswer(message.from, message.sdp);
                            }.bind(this));
                        }
                        break;

                    case PeerConnection.DESCRIPTION_TYPE_ANSWER:
                        console.log('Local description set');
                        console.dir(sessionDescription);
                        this.peer.setRemoteDescription(sessionDescription);
                        this.observer.onConnectionCompleted();
                        break;
                }
            }
            break;

        case PeerConnection.MESSAGE_TYPE_CANDIDATE:
            if ( message.candidate ) {
                candidate = new RTCIceCandidate(message.candidate);
                this.addIceCandidate(candidate);
            }
            break;

        case PeerConnection.MESSAGE_TYPE_CHAT:
            chat.createPost(message.data, false);
            break;

        case PeerConnection.MEMBER_ADDED:
            memberList.add(message.uuid, message.accessName);
            break;

        case PeerConnection.MEMBER_REMOVED:
            memberList.remove(message.uuid);
            break;
    }
};
Observer.onConnectionCompleted = function() {
    console.log('Peer connection succeed!');
    chat.start(this.dataChannel, this.streamChannel);
    remote.volume = 1;
    local.classList.add('connected');
};
Observer.onClosed = function() {
    remote.stop();
    chat.end();
    local.classList.remove('connected');
};

// ====================================================
// Peer Connection class
// ====================================================
function PeerConnection(observer) {
    this.observer    = this.bindObserver(observer);
    this.peer        = new RTCPeerConnection({"iceServers": server});
    this.connected   = false;
    this.personID    = null;

    this.dataChannel   = null;
    this.streamChannel = null;

    this.init();
    this.getUserMedia();
}

PeerConnection.DESCRIPTION_TYPE_OFFER  = "offer";
PeerConnection.DESCRIPTION_TYPE_ANSWER = "answer";
PeerConnection.MESSAGE_TYPE_SDP        = "sdp";
PeerConnection.MESSAGE_TYPE_CONNECTION = "connection";
PeerConnection.MESSAGE_TYPE_CANDIDATE  = "candidate";
PeerConnection.MESSAGE_TYPE_CHAT       = "chat";
PeerConnection.MEMBER_ADDED            = "member-added";
PeerConnection.MEMBER_REMOVED          = "member-removed";

PeerConnection.prototype.init = function() {
    this.peer.onicecandidate      = this.observer.onIceCandidate;
    this.peer.onaddstream         = this.observer.onAddStream;
    this.peer.onnegotiationneeded = this.observer.onNegotiationNeeded;
    websocket.onmessage           = this.observer.onWebSocketMessage;
};

PeerConnection.prototype.initDataChannel = function(channel) {
    console.log('Initialized data channel');
    this.dataChannel = DataStream.create(channel);
};

PeerConnection.prototype.initFileChannel = function(channel) {
    console.log('Initialized file channel');
    this.streamChannel = DataStream.create(channel);
};

PeerConnection.prototype.close = function() {
    this.peer.close();
    this.observer.onClosed();
};

PeerConnection.prototype.bindObserver = function(observer) {
    var that = this;

    Object.keys(observer).forEach(function(key) {
        observer[key] = observer[key].bind(that);
    });

    return observer;
};

PeerConnection.prototype.addIceCandidate = function(candidate) {
    this.peer.addIceCandidate(candidate);
};

PeerConnection.prototype.createOffer = function(id) {
    console.log('Offer send: ' + id);
    var constraints = {
        mandatory: {
            OfferToReceiveAudio: true,
            OfferToReceiveVideo: true
        }
    };

    // crate data channel
    this.initDataChannel(this.peer.createDataChannel('RTCDataConnection'));
    this.initFileChannel(this.peer.createDataChannel('RTCStreamConnection'));
    this.peer.createOffer(function(description) {
        console.log('Offered SDP:' + description);
        this.peer.setLocalDescription(description, function() {
            websocket.send(JSON.stringify({
                "type":     PeerConnection.MESSAGE_TYPE_SDP,
                "sdp" :     description,
                "to"  :     id,
                "from":     uuid,
                "accessName": accessName
            }));
        });
        this.personID = id;
    }.bind(this),
    function (err) {
        console.error(err);
    }, constraints);
};

PeerConnection.prototype.createAnswer = function(id, sdp) {
    console.log('Answer send: ' + id);
    var constraints = {
        mandatory: {
            OfferToReceiveAudio: true,
            OfferToReceiveVideo: true
        }
    };

    this.peer.createAnswer(function(description) {
        console.log('Answered SDP:' + description);
        var bit = 0x0;

        this.peer.setLocalDescription(description, function() {
            websocket.send(JSON.stringify({
                "type":     PeerConnection.MESSAGE_TYPE_SDP,
                "sdp" :     description,
                "to"  :     id,
                "from":     uuid
            }));
        });
        this.personID = id;
        this.peer.ondatachannel  = function(evt) {
            console.log('Handled datachannel event');
            console.log(evt);
            switch ( evt.channel.label ) {
                case 'RTCDataConnection':
                    this.initDataChannel(evt.channel);
                    bit |= 0x1;
                    break;

                case 'RTCStreamConnection':
                    this.initFileChannel(evt.channel);
                    bit |= 0x2;
                    break;
            }
            
            if ( (bit ^ 0x3) === 0 ) {
                this.observer.onConnectionCompleted();
            }
        }.bind(this);

    }.bind(this),
    function (err) {
        console.error(err);
    }, constraints);
};

PeerConnection.prototype.getUserMedia = function() {
    var peer = this.peer;

    navigator.webkitGetUserMedia(
        { audio: true, video: true },
        function(stream) {
            console.log('Media loaded');
            local.src = window.URL.createObjectURL(stream);
            peer.addStream(stream);
            websocket.send(JSON.stringify({
                "type":       PeerConnection.MEMBER_ADDED,
                "accessName": accessName,
                "uuid":       uuid
            }));
        },
        this.errorHandler
    );
};


PeerConnection.prototype.errorHandler = function(err) {
    console.log(err.name + ':' + err.message);
};

// ====================================================
// Connected member list class
// ====================================================
function MemberList(node) {
    this.node = node;
    this.stub = document.createElement('li');

    this.init();
}

MemberList.prototype.init = function() {
    this.node.addEventListener('click', function(evt) {
        var target,
            id;

        if ( evt.target.tagName === "LI" ) {
            id = evt.target.getAttribute('data-uuid').slice(4);
            peer.createOffer(id);
        }
    }, false);
};

MemberList.prototype.add = function(id, name) {
    if ( id === uuid ) {
        return;
    }

    var li = this.stub.cloneNode();

    li.setAttribute('data-uuid', 'uuid' + id);
    li.appendChild(document.createTextNode('member: ' + name));
    this.node.appendChild(li);
    li.classList.add('active');
};

MemberList.prototype.remove = function(id) {
    var li   = this.node.querySelector('[data-uuid="uuid' + id + '"]'),
        node = this.node;

    if ( li ) {
        li.classList.remove('active');
        setTimeout(function() {
            node.removeChild(li);
        }, 1000);
    }
};

// ====================================================
// Connected member chat class
// ====================================================
function MemberChat(node) {
    this.node    = node;
    this.post    = null;
    this.input   = null;
    this.stub    = null;
    this.upload  = null;
    this.dataChannel   = null;
    this.streamChannel = null;
    this.isCompositing = false;
    this.beforePost    = "";

    this.stackFiles = [];
    this.fileReceiveAccepted = false;

    this.init();
}

MemberChat.prototype.init = function() {
    this.post   = this.node.querySelector('.post');
    this.input  = this.node.querySelector('#chat');
    this.stub   = doc.createElement('div');

    this.input.addEventListener('keydown',          this, false);
    this.input.addEventListener('compositionstart', this, false);
    this.input.addEventListener('compositionend',   this, false);

    this.input.disabled = true;
};

MemberChat.prototype.start = function(dataChannel, streamChannel) {
    this.dataChannel        = dataChannel;
    this.streamChannel      = streamChannel;
    this.input.disabled     = false;
    this.node.style.opacity = 1;

    this.upload = new DragDrop(this.node.querySelector('#droparea'));
    this.upload.start(function(fileData) {
        console.log('file raded');
        console.log(fileData);

        this.dataChannel.send(JSON.stringify({
            "type": "__FILE_REQUESTED__",
            "data": fileData.name,
            "size": fileData.size
        }));
        this.stackFiles.push(fileData);
        this.createPost(fileData.name + 'を送信中…');
    }.bind(this));

    this.dataChannel.on('end', function(data) {
        console.log('datachannel end');
        var json;

        try {
            json = JSON.parse(data);

            switch ( json.type ) {
                case "__TEXT__":
                    this.createPost(json.data, false);
                    break;

                case "__FILE_REQUESTED__":
                    this.confirmFileReceive(json.data, json.size);
                    break;

                case "__FILE_ACCEPTED__":
                    this.sendStackedFile(json.data);
                    this.createPost(json.data + 'を送信しました。', true);
                    break;

                case "__FILE_REJECTED__":
                    this.rejectStackFile(json.data);
                    this.createPost(json.data + 'の送信は拒否されました。', true);
                    break;
            }
        } catch ( e ) {
            console.log(e);
            this.createPost(data);
        }
    }.bind(this));

    this.streamChannel.on('end', function(aryBuf) {
        console.log('stream received');
        console.log(aryBuf);
        this.createPost(aryBuf);
    }.bind(this));

    // debug
    this.dataChannel.on('sended', function() {
        console.log('data sended');
    });
    this.dataChannel.on('data', function(data) {
        console.log('datachannel received');
        console.log(data);
    });
};

MemberChat.prototype.end = function() {
    this.input.disabled     = true;
    this.node.style.opacity = 0.2;

    this.upload.stop();
};

MemberChat.prototype.handleEvent = function(evt) {
    var value;

    switch ( evt.type ) {
        case 'keydown':
            if ( evt.keyCode == 27 ) {
                try {
                    peer.close();
                } catch ( e ) {}
                return;
            }

            value = this.input.value.trim();
            if ( value === "" || this.isCompositing === true || evt.keyCode != 13 ) {
                return;
            }
            evt.preventDefault();
            // simple validation
            if ( value === this.beforePost ) {
                console.log("同じ投稿はやめテ！");
                return;
            }
            this.beforePost  = value;
            this.input.value = "";
            this.dataChannel.send(JSON.stringify({
                "type": "__TEXT__",
                "data": value
            }));
            this.createPost(value, true);
            break;

        case 'compositionstart':
            this.isCompositing = true;
            break;

        case 'compositionend':
            this.isCompositing = false;
            break;
    }
};

MemberChat.prototype.createPost = function(value, isSelf) {
    var div = this.stub.cloneNode(),
        a,
        file,
        blob;

    if ( isSelf ) {
        div.classList.add('self');
    }

    if ( value instanceof Uint8Array ) { // TypedArray case
        file = this.fileReceiveAccepted;
        a = doc.createElement('a');
        a.download = file[0];
        blob = new Blob([value]);
        a.href = window.URL.createObjectURL(blob);
        a.appendChild(doc.createTextNode(this.fileReceiveAccepted[0] + '(約' + this.formatFileSize(file[1]) + ')'));
        file[2].normalize();
        file[2].replaceChild(a, file[2].firstChild);
        this.fileReceiveAccepted = false;
    } else {
        div.appendChild(doc.createTextNode(value));
    }

    if ( this.post.firstChild ) {
        this.post.insertBefore(div, this.post.firstChild);
    } else {
        this.post.appendChild(div);
    }

    return div;
};

MemberChat.prototype.confirmFileReceive = function(fileName, fileSize) {
    var size = this.formatFileSize(fileSize),
        conf = confirm(fileName + '（約' + size + '）の送信要求が届いています。受信しますか？'),
        post;

    if ( conf ) {
        post = this.createPost(fileName + 'を受信中…(0/' + fileSize + ')');
        this.fileReceiveAccepted = [fileName, fileSize, post];
        this.dataChannel.send(JSON.stringify({
            "type": "__FILE_ACCEPTED__",
            "data": fileName
        }));
    } else {
        this.fileReceiveAccepted = false;
        this.dataChannel.send(JSON.stringify({
            "type": "__FILE_REJECTED__",
            "data": fileName
        }));
    }
};

MemberChat.prototype.formatFileSize = function(size) {
    var suffix = ["Byte", "KB", "MB", "GB", "TB"],
        index  = 0,
        byte   = 1024;

    while ( size > byte ) {
        size /= byte;
        ++index;
    }

    return (size|0) + suffix[index];
};

MemberChat.prototype.sendStackedFile = function(fileName) {
    console.log(this.stackFiles);
    var file = this.getFile(fileName);

    console.log('stacked file');
    console.log(file);
    if ( ! file ) {
        console.log('Send file is not found.');
        return;
    }

    this.streamChannel.send(file.buffer);
};

MemberChat.prototype.getFile = function(fileName) {
    var fileData,
        size = this.stackFiles.length,
        i    = 0;

    for ( ; i < size; ++i ) {
        if ( this.stackFiles[i].name === fileName ) {
            fileData = this.stackFiles[i];
            this.stackFiles.splice(i, 1);
            break;
        }
    }

    return fileData;
};


MemberChat.prototype.rejectStackFile = function(fileName) {
    // simply delete file object if exists
    this.getFile(fileName);
};

// ====================================================
// UUID class
// ====================================================
function UUID() {
    // @see http://codedehitokoto.blogspot.jp/2012/01/javascriptuuid.html
    this.uuid = [
        (((1+Math.random())*0x10000)|0).toString(16).substring(1),
        (((1+Math.random())*0x10000)|0).toString(16).substring(1),
        (((1+Math.random())*0x10000)|0).toString(16).substring(1),
        (((1+Math.random())*0x10000)|0).toString(16).substring(1),
        (((1+Math.random())*0x10000)|0).toString(16).substring(1),
        (((1+Math.random())*0x10000)|0).toString(16).substring(1),
        (((1+Math.random())*0x10000)|0).toString(16).substring(1),
        (((1+Math.random())*0x10000)|0).toString(16).substring(1)
    ].join("");

    this.init();
}

UUID.prototype.init = function() {
    var sign = doc.createElement('p'),
        node = doc.getElementById('uuid');

    sign.appendChild(doc.createTextNode('Your Peer connection id:  ' + this.uuid));
    node.appendChild(sign);
    node.classList.add('show');
};

UUID.prototype.toString = function() {
    return this.uuid;
};

// ====================================================
// Drag drop management class
// ====================================================
function DragDrop(node) {
    this.node   = node;
    this.ondrop = null;
}

DragDrop.prototype.start = function(fn) {
    var doc  = document,
        drop = this.node;

    drop.setAttribute('draggable', 'on');
    drop.style.KhtmlUserDrag    = 'element';
    drop.style.WebkitUserDrag   = 'element';
    drop.style.KhtmlUserSelect  = 'none';
    drop.style.WebkitUserSelect = 'none';

    doc.addEventListener('dragenter', this, false);
    doc.addEventListener('dragover',  this, false);
    doc.addEventListener('dragleave', this, false);

    // Drop element event handle
    drop.addEventListener('dragenter', this.cancelEvent, false);
    drop.addEventListener('dragover',  this.cancelEvent, false);
    drop.addEventListener('dragleave', this.cancelEvent, false);
    drop.addEventListener('drop',      this,             false);
    console.log('event start');

    this.ondrop = fn || this.ondrop;
};

DragDrop.prototype.cancelEvent = function(evt) {
    evt.preventDefault();
    evt.stopPropagation();
};

DragDrop.prototype.handleEvent = function(evt) {
    console.log('event: ' + evt.type);
    switch ( evt.type ) {
        case 'dragenter':
        case 'dragover':
            this.node.style.display = 'block';
            break;

        case 'dragleave':
            if ( evt.target === document.body || evt.clientX <= 0 || evt.clientY <= 0 ) {
                this.node.style.display = 'none';
            }
            break;

        case 'drop':
            this.cancelEvent(evt);

            this.handleDropFile(evt.dataTransfer.files[0]);
            this.node.style.display = 'none';
            break;
    }
};

DragDrop.prototype.handleDropFile = function(file) {
    var fr       = new FileReader(),
        fileData = {name: file.fileName || file.name},
        handler  = this.ondrop;

    fr.onload = function(evt) {
        fileData.buffer = evt.target.result;
        fileData.size   = evt.target.result.byteLength;
        handler(fileData);
    };

    fr.onerror = function(e) {
        throw new Error('File Read Error');
    };

    fr.readAsArrayBuffer(file);
};

DragDrop.prototype.stop = function() {
    var doc  = document,
        drop = this.node;

    doc.removeEventListener('dragenter', this);
    doc.removeEventListener('dragleave', this);
    drop.removeEventListener('drop',     this);
}


function DataStream(connection) {
    this.conn      = connection;
    this.callbacks = {};
    this.chunk     = null;
    this.MAX_BYTES = 64 * 1024;
}

DataStream.create = function(connection) {
    var instance =  new DataStream(connection);

    instance.init();
    return instance;
};

DataStream.prototype.init = function() {
    var that = this;

    this.conn.onmessage = function(evt) {
        var chunk = evt.data,
            uint8;

        if ( chunk === "\0" ) {
            this._dispatch('end', this.chunk);
            this.chunk = null;
            return;
        }

        if ( chunk instanceof ArrayBuffer ) {
            if ( this.chunk === null ) {
                uint8 = new Uint8Array(chunk);
            } else {
                uint8 = new Uint8Array(this.chunk.byteLength + chunk.byteLength);
                uint8.set(new Uint8Array(this.chunk), 0);
                uint8.set(new Uint8Array(chunk), this.chunk.byteLength);
            }
            this.chunk = uint8;
        } else {
            if ( this.chunk === null ) {
                this.chunk = chunk;
            } else {
                this.chunk += chunk;
            }
        }

        this._dispatch('data', chunk);
    }.bind(this);
};

DataStream.prototype.on = function(type, callback) {
    if ( ! (type in this.callbacks) ) {
        this.callbacks[type] = [];
    }

    this.callbacks[type].push(callback);
};

DataStream.prototype._sendChunk = function(chunk) {
    this.conn.send(chunk);
};

DataStream.prototype._dispatch = function(type, data) {
    if ( type in this.callbacks ) {
        this.callbacks[type].forEach(function(callback) {
            callback(data);
        });
    }
};

DataStream.prototype.send = function(data) {
    var that     = this,
        index    = 0,
        size     = this.getDataSize(data),
        maxBytes = this.MAX_BYTES,
        chunk;

    if ( size > maxBytes ) {
        do {
            if ( index + maxBytes > size ) {
                chunk = data.slice(index, size);
            } else {
                chunk = data.slice(index, index + maxBytes);
            }

            console.log(chunk);
            this._sendChunk(chunk);
            index += maxBytes;
        } while ( size > index );
        this._sendChunk("\0");
        this._dispatch('sended');
        //(function _sendChunk() {
        //    var chunk = data.slice(index, index + maxBytes);

        //    index += maxBytes;
        //    that._sendChunk(chunk);
        //    if ( size > index ) {
        //        _sendChunk();
        //    } else {
        //        that._sendChunk("\0");
        //        that._dispatch('sended');
        //    }
        //})();
    } else {
        this._sendChunk(data);
        this._sendChunk("\0");
        this._dispatch('sended');
    }
};

DataStream.prototype.getDataSize = function(data) {
    return data.byteLength || data.length;
};


    // Check connection name
    do {
        accessName = prompt('Enter your access name');
    } while ( accessName === "" );

    if ( accessName === "" ) {
        alert('Connected Canceled.');
        location.reload();
    }

    // volume 0
    local.volume  = 0;
    remote.volume = 0;

    // Class Instantiate
    websocket  = new WebSocket(socketURL);
    peer       = new PeerConnection(Observer);
    memberList = new MemberList(members);
    chat       = new MemberChat(document.getElementById('chatSection'));
    uuid       = (new UUID())+""; // get string

    window.addEventListener('unload', function() {
        websocket.send(JSON.stringify({
            "type": PeerConnection.MEMBER_REMOVED,
            "uuid": uuid
        }));
        try {
            peer.close();
        } catch ( e ) {} 
    });

    window.peer = peer;
}, false);

